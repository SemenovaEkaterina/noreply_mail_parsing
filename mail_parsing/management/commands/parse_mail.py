import email
import os
import re
import signal
import sys
from datetime import datetime

from django.core.files.base import ContentFile
from django.core.management.base import BaseCommand

import mail_parsing.management.commands.scripts.header_parser as header_parser
import mail_parsing.management.commands.scripts.message_parser as parser
from mail_parsing.management.commands.scripts.connection import make_message_list
from mail_parsing.models import EmailAddress, Message, Attachment


WRONG_HEADERS_VALS = [
    ('Auto-Submitted', 'auto-replied'),
    ('auto-submitted', 'auto-generated'),
    ('Precedence', 'bulk'),
    # ('X-Autoreply', 'yes'),
    # ('X-Autoreply', 'Yes'),
    ('X-Autoreply', ''),
    ('X-Autogenerated', ''),
    ('X-Failed-Recipients', ''),
    ('X-Mailer-Daemon-Recipients', ''),
    ('X-MS-Exchange-Message-Is-Ndr', ''),
    ('x-ms-exchange-generated-message-source', 'Mailbox Rules Agent'),
    ('X-MS-Exchange-Inbox-Rules-Loop', ''),  # ?
    ('X-Auto-Response-Suppress', 'All'),  # не факт
    ('X-Autoreply-From', ''),
]

# Отсутствует: в начале темы тоже м.б.
WRONG_SUBJECTS_CONTAINS = [
    'Mail failure.',
    'Undelivered Mail Returned to Sender',
    'Undeliverable mail: ',
    'failure notice',
    'Не удается доставить: ',
    'Delivery Status Notification (Failure)',
    'Undeliverable: ',
    'Delivery Notification: Delivery has failed',
    'Automatic reply: ',
    'Delivery failure',
    'Карантин (Quarantine)',
    '- User unknown!',
    'Автоматический ответ: ',
    'Доставка отложена:',
    'Auto reply: ',
    'Undeliverable mail:',
    'Returned mail: see transcript for details',
    'Mail Delivery Failure',
    'Mail delivery failed: returning message to sender',
    'Unzustellbar:',
    'perm error',
    'Delivery status notification',
    'Warning: message ',
    'В Ваш аккаунт выполнен вход с устройства',
]

WRONG_FROM_CONTAINS = [
    'mailer-daemon',
    'postmaster',
    'spamfilter.admin',
    'mdaemon at ',
    'mail-daemon',
    'no-reply@',
]

# Mailbox size limit exceed
LIMIT_EXCEED_HEADERS_VALS = [
    ('X-Mailer-Daemon-Error', 'full_mailbox'),
]

LIMIT_EXCEED_TEXT = [
    'maximum mailbox size',
    'Mailbox size limit exceeded',
    'mailbox is full',
    # 'temporary',
    'Recipient address rejected: Recipient undeliverable (not exists, blocked, over qouta, etc)',
    'messages count limit',
    'email account that you tried to reach is over quota',
    '552-5.2.2',  # mailbox quota exceeded for this recipient
    '552 5.2.2',
    '552-5.2.3',  # Message exceeds local size limit
    '552 5.2.3',
    '554-5.7.1',  # Access denied            ?
    '554 5.7.1',
    'Mail quota exceeded',
    'mailfolder is full',
]



# Invalid address:
# 'invalid mailbox'
# 'user not found'
# 'No Such User Here'
# 'User unknown'
# 'email account that you tried to reach does not exist'
# 'Unrouteable address'
# '550-5.1.1' # addr not found
# '550 5.1.1'
# '550-5.2.1'
# '550 5.2.1'
# 'No such user!'
# '550-5.7.1' # No such user
# '550 5.7.1'
# 'account is disabled' #                 ?
# 'recipient does not have an account'

UNDELIVERED_STATUS = [
    '5.0.0',
    '4.4.1',  # connection timed out
    '5.4.4',
    '5.7.1',
    '4.4.3',
    '5.4.6',  # mail loops back to myself
    '5.2.1',
    '4.0.0',  # mail receiving disabled
    '4.1.1',  # address rejected: unverified address
    '4.7.1',  # You are not allowed to connect
    '4.4.2',  # lost connection
    '5.7.606',  # Access denied, banned sending IP
    '5.5.0',  # user not found
    '4.4.7',  # No recipients
    '5.1.2',  # recipient address is not a valid
    '5.4.1',  # Recipient address rejected: Access denied
    '5.5.4',  # Error: send AUTH command first
]

OVER_QUOTA_STATUS = [
    '4.2.2',
    '5.2.2',
    '5.1.1',  # account is full
    '5.7.0',  # maildir over quota
]


def parse_timeout_signal_handler(signum, frame):
    raise Exception("Time Out")


def write_error_original(msg, num):
    try:
        r = open('error_messages/original_' + str(num) + '.txt', 'w')
        r.write(msg.as_bytes().decode(encoding='UTF-8'))
        r.close()
    except:
        pass


class Command(BaseCommand):
    def handle(self, *args, **options):

        errors_file = open('errors.txt', 'a')
        message_ids, mail, result = make_message_list('UNSEEN')
        if result != 'OK':
            errors_file.write(str(datetime.now()) + ' ' + result + '\n')
            errors_file.close()
            sys.exit(1)

        # print(len(message_ids))

        min_id = os.environ.get('MIN_ID', 0)
        max_id = os.environ.get('MAX_ID', 1000000)

        max_count = os.environ.get('MAX_COUNT', 1000)
        count = 0

        for i in message_ids:

            try:
                msg_num = i.decode()

                if int(msg_num) <= int(min_id) or int(msg_num) > int(max_id):
                    continue

                if count > int(max_count):
                    break

                count += 1

                # print()
                # print(i)

                try:
                    res, encoded_message = mail.fetch(i, '(RFC822)')
                except:
                    try:
                        mail.store(i, '-FLAGS', '\\SEEN')
                    except:
                        sys.exit(1)
                    continue

                try:
                    message = email.message_from_bytes(encoded_message[0][1])
                except:
                    errors_file.write(str(datetime.now()) + ' ' + 'ERROR: failed to get message from bytes ' + str(msg_num) + '\n')
                    write_error_original(message, msg_num)
                    try:
                        mail.store(i, '-FLAGS', '\\SEEN')
                    except:
                        sys.exit(1)
                    continue

                if header_parser.header_parse('X-SPAM-FLAG') == 'YES':
                    continue

                go_next = False

                no_such_user = 0
                limit_exceed = False
                autoreply = 0
                spam = False

                # Message contains part with delivery-status
                if message.get_content_type() == 'multipart/report':
                    no_such_user += 0.2
                    for param in message.get_params(failobj=[]):
                        if param[0] == 'report-type' and param[1] == 'delivery-status':
                            no_such_user += 0.2

                    for part in message.walk():
                        # Поиск по заголовкам message/delivery-status на предмет кодов ошибок
                        # (UNDELIVERED_STATUS, OVER_QUOTA_STATUS)
                        if part.get_content_type().lower() == 'message/delivery-status':

                            try:
                                payload = part.get_payload(1)
                            except:
                                continue

                            header_status = header_parser.header_parse(payload, 'Status')
                            if header_status in UNDELIVERED_STATUS:
                                no_such_user += 0.4
                            if header_status in OVER_QUOTA_STATUS:
                                no_such_user += 0.4
                                limit_exceed = True

                            address = header_parser.header_parse(payload, 'Original-Recipient')
                            if address is not None:
                                address = re.sub(r'rfc822; ?', '', address)
                                go_next = True
                            else:
                                address = header_parser.header_parse(payload, 'Final-Recipient')
                                if address is not None:
                                    address = re.sub(r'rfc822; ?', '', address)
                                    go_next = True

                if go_next:
                    if limit_exceed:
                        limit_exceed_chance = 1
                    else:
                        limit_exceed_chance = 0
                    try:
                        EmailAddress.objects.create(address=address,
                                                    limit_exceed_chance=limit_exceed_chance,
                                                    detected_spam_chance=0)
                    except:
                        errors_file.write(str(datetime.now()) + ' ' + 'ERROR: failed to save EmailAddress ' + str(msg_num) + '\n')
                        write_error_original(message, msg_num)
                        try:
                            mail.store(i, '-FLAGS', '\\SEEN')
                        except:
                            sys.exit(1)
                    continue

                if header_parser.header_parse(message, 'X-Mailer-Daemon-Error') == 'user_not_found':
                    no_such_user += 0.8

                # Autoreply
                # Ex:
                # Reply-To: 123.autoreply@gmail.com
                # Return-Path: 123.autoreply@gmail.com or MAILER-DAEMON@corp.mail.ru
                # Errors-To: 123.autoreply@gmail.com

                if header_parser.header_parse(message, 'Reply-To') is not None:
                    if 'autoreply' in header_parser.header_parse(message, 'Reply-To').lower():
                        autoreply += 0.2

                if header_parser.header_parse(message, 'Return-Path') is not None:
                    for wrong_from in WRONG_FROM_CONTAINS:
                        if wrong_from in header_parser.header_parse(message, 'Return-Path').lower():
                            autoreply += 0.2
                    if 'autoreply' in header_parser.header_parse(message, 'Return-Path').lower():
                        autoreply += 0.2

                if header_parser.header_parse(message, 'Errors-To') is not None:
                    if 'autoreply' in header_parser.header_parse(message, 'Errors-To'):
                        autoreply += 0.2

                if header_parser.header_parse(message, 'X-Autoreply') is not None:
                    autoreply += 0.2

                # Если автоответ, то со оригинального адреса
                wrong_from_in = False
                message_from = header_parser.header_parse(message, 'From')

                if message_from is not None:
                    for wrong_from in WRONG_FROM_CONTAINS:
                        if wrong_from in message_from.lower():
                            wrong_from_in = True
                            no_such_user += 0.4
                else:
                    message_from = ''

                # При наборе остальных признаков отличит автоовет
                if not wrong_from_in:
                    autoreply += 0.2

                if header_parser.header_parse(message, 'X-Autogenerated') == header_parser.header_parse(message, 'From') or header_parser.header_parse(message, 'X-Autogenerated') == 'Reply':
                    # В любом случае автоответчик
                    continue

                # Поиск по темам (WRONG_SUBJECTS_CONTAINS)
                message_subject = header_parser.header_parse(message, 'Subject')
                if message_subject is not None:
                    for wrong_subject_part in WRONG_SUBJECTS_CONTAINS:
                        if wrong_subject_part.lower() in message_subject.lower():
                            no_such_user += 0.4
                            autoreply += 0.4
                else:
                    message_subject = ''

                # По заголовкам (WRONG_HEADERS_VALS)
                for wrong_header_wval in WRONG_HEADERS_VALS:
                    hname, hval = wrong_header_wval
                    hfiltered = header_parser.header_parse(message, hname)
                    if hfiltered is not None:
                        if hval in hfiltered:
                            no_such_user += 0.2
                            autoreply += 0.2

                if autoreply >= 0.8 and autoreply > no_such_user:
                    continue

                if no_such_user >= 0.8:
                    for limit_header_wval in LIMIT_EXCEED_HEADERS_VALS:
                        hname, hval = limit_header_wval
                        hfiltered = header_parser.header_parse(message, hname)
                        if hfiltered is not None:
                            if hval in hfiltered:
                                limit_exceed = True

                    header_failed_address = header_parser.header_parse(message, 'X-Failed-Recipients')
                    if header_failed_address is None:
                        header_failed_address = header_parser.header_parse(message, 'X-Mailer-Daemon-Recipients')

                    if header_failed_address is not None:
                        address = header_failed_address

                    invalid_list = []

                    for part in message.walk():
                        payload = part.get_payload(decode=True)
                        if payload is not None:
                            # + text/html ?
                            if part.get_content_type() == 'text/plain':
                                charset = part.get_content_charset(failobj=None)
                                if charset is not None:
                                    try:
                                        decoded_part = payload.decode(str(charset), "ignore")
                                    except LookupError:
                                        decoded_part = payload.decode()
                                else:
                                    try:
                                        decoded_part = payload.decode()
                                    except:
                                        pass
                                    decoded_part = str(payload)

                                if decoded_part is None:
                                    continue

                                if 'looks like SPAM' in decoded_part:
                                    spam = True
                                    break

                                for text in LIMIT_EXCEED_TEXT:
                                    if text in decoded_part:
                                        limit_exceed = True
                                        break
                                if address is None:
                                    address_list = re.findall(r'[\w\.-]+@[\w\.-]+', decoded_part)

                                    for address in address_list:

                                        address = address.strip('<>').lower()
                                        daemon_address = False

                                        for wrong_from in WRONG_FROM_CONTAINS:
                                            if wrong_from in address:
                                                daemon_address = True

                                        if address != os.environ.get(
                                            'EMAIL') and not daemon_address and address not in invalid_list:
                                            invalid_list.append(address)

                    if len(invalid_list) != 1 and address is None:
                        # print("ERRROR: not one invalid address in text")
                        continue

                    if len(invalid_list) == 1 and address is None:
                        address = invalid_list[0]

                    if address is not None:
                        if spam:
                            detected_spam_chance = 1
                        else:
                            detected_spam_chance = 0
                        if limit_exceed:
                            limit_exceed_chance = 1
                        else:
                            limit_exceed_chance = 0
                        try:
                            EmailAddress.objects.create(address=address,
                                                        limit_exceed_chance=limit_exceed_chance,
                                                        detected_spam_chance=detected_spam_chance)
                        except:
                            try:
                                errors_file.write(str(datetime.now()) + ' ' + 'ERROR: failed to save EmailAddress ' + str(msg_num) + '\n')
                                write_error_original(message, msg_num)
                                mail.store(i, '-FLAGS', '\\SEEN')
                            except:
                                sys.exit(1)
                        continue

                    else:
                        errors_file.write(str(datetime.now()) + ' ' + 'ERROR: failed to find EmailAddress ' + str(msg_num) + '\n')
                        write_error_original(msg_num)
                        try:
                            mail.store(i, '-FLAGS', '\\SEEN')
                        except:
                            sys.exit(1)
                        continue

                parts = []
                parsed_html = None
                parsed_plain = None
                # 0 - ответ на сообщение в системе: <v1-message...>
                # 1- остальные
                message_type = 1

                # Разбор In-Reply-To, определение типа
                in_reply_to_header = header_parser.header_parse(message, 'In-Reply-To')
                if in_reply_to_header is not None:
                    in_reply_to_header = re.search(r'<.+@eljur.ru>', in_reply_to_header)
                    if in_reply_to_header is not None:
                        in_reply_to_header = in_reply_to_header.group()[1:-10]
                        if in_reply_to_header[3:10] == 'message':
                            message_type = 0
                    else:
                        in_reply_to_header = ''
                else:
                    in_reply_to_header = ''

                try:
                    original = message.__str__()
                except KeyError:
                    try:
                        original = message.as_bytes().decode(encoding=message.get_content_charset())
                    except:
                        try:
                            original = message.as_bytes().decode(encoding='UTF-8')
                        except:
                            try:
                                mail.store(i, '-FLAGS', '\\SEEN')
                            except:
                                sys.exit(1)
                                errors_file.write(
                                    str(datetime.now()) + ' ' + 'ERROR: failed to decode original ' + str(msg_num) + '\n')
                            continue

                message_object = Message(msg_from=message_from,
                                         subject=message_subject,
                                         in_reply_to_header=in_reply_to_header,
                                         type=message_type,
                                         original=original)

                for part in message.walk():

                    payload = part.get_payload(decode=True)
                    if payload is not None:

                        charset = part.get_content_charset(failobj=None)

                        if charset is None:
                            decoded_part = str(payload)
                        else:
                            try:
                                decoded_part = payload.decode(str(charset), "ignore")
                            except LookupError:
                                decoded_part = payload.decode()

                        header_content_disposition = header_parser.header_parse(part, 'Content-Disposition')

                        attachment_part = False

                        if part.get_filename() is not None or header_content_disposition == 'attachment':
                            attachment_part = True
                            if part.get_filename() is not None:
                                file_name = email.header.decode_header(part.get_filename())
                            else:
                                try:
                                    file_format = '.' + part.get_subtype()
                                except:
                                    file_format = ''
                                file_name = '1' + file_format
                            if isinstance(file_name[0][0], str):
                                file_name = file_name[0][0]
                            else:
                                try:
                                    file_name = file_name[0][0].decode(file_name[0][1])
                                except:
                                    try:
                                        file_format = '.' + part.get_subtype()
                                    except:
                                        file_format = ''
                                    file_name = '1' + file_format

                            message_object.save()
                            try:
                                message_object.save()
                            except:
                                go_next = True
                                errors_file.write(
                                    str(datetime.now()) + ' ' + 'ERROR: failed to save message ' + str(msg_num) + '\n')
                                try:
                                    mail.store(i, '-FLAGS', '\\SEEN')
                                except:
                                    sys.exit(1)
                                write_error_original(message, msg_num)

                            at = Attachment()
                            at.message = message_object
                            try:
                                at.file.save(str(message_object.id) + '_' + file_name, ContentFile(payload))
                            except:
                                go_next = True
                                errors_file.write(
                                    str(datetime.now()) + ' ' + 'ERROR: failed to save attachment ' + str(msg_num) + '\n')
                                try:
                                    mail.store(i, '-FLAGS', '\\SEEN')
                                except:
                                    sys.exit(1)
                                write_error_original(message, msg_num)

                        if decoded_part is not None and attachment_part is False:
                            try:
                                if part.get_content_type() == 'text/plain':
                                    decoded_part = decoded_part.strip()
                                    parts.append(decoded_part.strip())
                                    signal.signal(signal.SIGALRM, parse_timeout_signal_handler)
                                    signal.alarm(10)
                                    try:
                                        parsed_plain = parser.parse(decoded_part)
                                        signal.alarm(0)
                                    except Exception:
                                        errors_file.write(
                                            str(datetime.now()) + ' ' + 'ERROR: plain parse time out ' + str(msg_num) + '\n')
                                        continue


                            except TypeError:
                                errors_file.write(
                                    str(datetime.now()) + ' ' + 'ERROR: typeError ' + str(msg_num) + '\n')

                            try:
                                if part.get_content_type() == 'text/html' and attachment_part == False:
                                    parts.append(decoded_part)
                                    signal.signal(signal.SIGALRM, parse_timeout_signal_handler)
                                    signal.alarm(50)
                                    try:
                                        parsed_html = parser.parse_html(decoded_part, charset)
                                        signal.alarm(0)
                                    except Exception:
                                        errors_file.write(
                                            str(datetime.now()) + ' ' + 'ERROR: plain parse time out ' + str(
                                                msg_num) + '\n')
                                        continue
                            except TypeError:
                                errors_file.write(
                                    str(datetime.now()) + ' ' + 'ERROR: typeError ' + str(msg_num) + '\n')

                        else:
                            if (part.get_content_type() == 'text/plain' or part.get_content_type() == 'text/html') and attachment_part == False:
                                write_error_original(message, msg_num)
                                errors_file.write(
                                    str(datetime.now()) + ' ' + 'ERROR: no decoded part ' + str(msg_num) + '\n')
                                try:
                                    mail.store(i, '-FLAGS', '\\SEEN')
                                except:
                                    sys.exit(1)
                                continue
                    else:
                        if part.get_content_type == 'text/plain' or part.get_content_type() == 'text/html' \
                                or header_parser.header_parse(part, 'Content-Disposition') == 'attachment':
                            errors_file.write(
                                str(datetime.now()) + ' ' + 'ERROR: no payload ' + str(msg_num) + '\n')
                            write_error_original(message, msg_num)
                            try:
                                mail.store(i, '-FLAGS', '\\SEEN')
                            except:
                                sys.exit(1)
                            go_next = True
                            break

                if go_next:
                    continue

                if not len(parts) and not attachment_part:
                    errors_file.write(
                        str(datetime.now()) + ' ' + 'ERROR: no correct parts ' + str(msg_num) + '\n')
                    write_error_original(message, msg_num)
                    try:
                        mail.store(i, '-FLAGS', '\\SEEN')
                    except:
                        sys.exit(1)
                    continue

                # print('OK: ' + str(msg_num))
                mail.store(i, '-FLAGS', '\\SEEN')

                if parsed_html is None:
                    if parsed_plain is not None:

                        message_object.text = parsed_plain[0]

                        if parsed_plain[2] == 0:
                            message_object.quote = parsed_plain[1]
                        try:
                            message_object.save()
                        except:
                            write_error_original(message, msg_num)
                            errors_file.write(
                                str(datetime.now()) + ' ' + 'ERROR: failed to save message ' + str(msg_num) + '\n')
                            try:
                                mail.store(i, '-FLAGS', '\\SEEN')
                            except:
                                sys.exit(1)
                            continue
                else:
                    message_object.text = parsed_html[0]
                    if parsed_html[2] == 0:
                        message_object.quote = parsed_html[1]
                    try:
                        message_object.save()
                    except:
                        write_error_original(message, msg_num)
                        errors_file.write(
                            str(datetime.now()) + ' ' + 'ERROR: failed to save message ' + str(msg_num) + '\n')
                        try:
                            mail.store(i, '-FLAGS', '\\SEEN')
                        except:
                            sys.exit(1)
                        continue
            except SystemExit:
                errors_file.write(str(datetime.now()) + ' ' + 'ERROR: failed to mark unseen' + '\n')
                errors_file.close()
                break
            except:
                try:
                    mail.store(i, '-FLAGS', '\\SEEN')
                except:
                    errors_file.write(str(datetime.now()) + ' ' + 'ERROR: failed to mark unseen' + '\n')
                    errors_file.close()
                    sys.exit(1)
                write_error_original(message, msg_num)
                errors_file.write(str(datetime.now()) + ' ' + 'ERROR: undefined_error' + '\n')

        errors_file.close()
        try:
            mail.close()
            mail.logout()
        except:
            pass
